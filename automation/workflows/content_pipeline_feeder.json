{
  "name": "Content Pipeline - Feeder",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "hours",
              "hoursInterval": 8
            }
          ]
        }
      },
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [-880, 640],
      "id": "99d7a881-c8cf-42f6-9beb-3f17bfa55abb",
      "name": "Schedule",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "resource": "databasePage",
        "operation": "getAll",
        "databaseId": {
          "__rl": true,
          "value": "https://www.notion.so/696682be460146f7b2b018ad3c106cec?v=25390f466795805e8466000c64898052&source=copy_link",
          "mode": "url"
        },
        "simple": false,
        "filterType": "manual",
        "filters": {
          "conditions": [
            {
              "key": "Active|checkbox",
              "condition": "equals",
              "checkboxValue": true
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.notion",
      "typeVersion": 2.2,
      "position": [-656, 640],
      "id": "fd3813f4-7e72-4aad-b732-ff4ee5aae0f8",
      "name": "Fetch Active Sources",
      "alwaysOutputData": true,
      "credentials": {
        "notionApi": {
          "id": "lC4G957VFihVvFG2",
          "name": "Notion account"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// Validates RSS feed URLs from Notion database and checks if sources are stale\n// Adds metadata for downstream processing and filters invalid sources\nconst out = [];\n\nfor (const it of $input.all()) {\n  // Your data has property_url directly, not nested in properties\n  const url = it.json.property_url; // Changed this line\n  const sourceName = it.json.property_source_name || it.json.name || \"Unknown\"; // Multiple fallbacks\n  const lastScraped = it.json.property_last_scraped?.start;\n\n  console.log(`Processing source: ${sourceName}, URL: ${url}`);\n\n  // Calculate staleness\n  let isStale = false;\n  if (lastScraped) {\n    const days = (Date.now() - new Date(lastScraped).getTime()) / 86400000;\n    isStale = days > 7;\n  }\n\n  // Add feed URL for downstream processing\n  it.json.feedUrl = url;\n  it.json.sourceName = sourceName;\n  it.json.isStale = isStale;\n\n  // Add validation status\n  it.json.isValidUrl = !!(url && /^https?:\\/\\//.test(url));\n  it.json.validationError = null;\n\n  // Add priority multiplier\n  it.json.priorityMultiplier = it.json.property_priority_multiplier || 1.0;\n\n  if (!url) {\n    it.json.validationError = \"No URL provided\";\n    console.log(`❌ ${sourceName}: No URL provided`);\n  } else if (!/^https?:\\/\\//.test(url)) {\n    it.json.validationError = \"Invalid URL format\";\n    console.log(`❌ ${sourceName}: Invalid URL format: ${url}`);\n  } else {\n    console.log(`✅ ${sourceName}: Valid URL: ${url}`);\n  }\n\n  // ALWAYS add to output\n  out.push(it);\n}\n\nconsole.log(\n  `Validated ${out.length} sources (${\n    out.filter((s) => s.json.isValidUrl).length\n  } valid, ${out.filter((s) => !s.json.isValidUrl).length} invalid)`\n);\n\nreturn out;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-208, 640],
      "id": "21fba95c-7d88-4d86-b6cf-902e7cd93856",
      "name": "Validate Sources"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [16, 640],
      "id": "fb7e7807-30ad-4dae-b098-027c9e27c4a2",
      "name": "Loop Feeds"
    },
    {
      "parameters": {
        "url": "={{ $json.property_url }}",
        "sendHeaders": true,
        "specifyHeaders": "json",
        "jsonHeaders": "{\n  \"User-Agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36\",\n  \"Accept\": \"application/rss+xml, application/xml, text/xml, */*;q=0.9\",\n  \"Accept-Language\": \"en-US,en;q=0.9\",\n  \"Cache-Control\": \"no-cache\"\n}",
        "options": {
          "response": {
            "response": {
              "responseFormat": "text"
            }
          },
          "timeout": 10000
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [256, 912],
      "id": "08c663b7-23c4-4ebc-98b0-ea7ab2244de2",
      "name": "Download RSS",
      "alwaysOutputData": true,
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "leftValue": "={{ $json.data }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty",
                "singleValue": true
              },
              "id": "7d77ebf5-d54d-484e-91ba-5626b4cbd652"
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [496, 912],
      "id": "65eb6bcf-28fe-4fad-afdb-fdad3fdd7578",
      "name": "Fetch OK?"
    },
    {
      "parameters": {
        "jsCode": "// Parses RSS and Atom feed XML into structured article objects\n// Handles both feed formats, extracts metadata, and cleans HTML content\nconst xml = $(\"Download RSS\").item.json.data || \"\";\nconst items = [];\n\nconsole.log(`Parsing feed data (${xml.length} characters)`);\n\n// Detect feed type\nconst isAtom =\n  xml.includes(\"<feed\") && xml.includes('xmlns=\"http://www.w3.org/2005/Atom\"');\nconst isRss = xml.includes(\"<rss\") || xml.includes(\"<item\");\n\nconsole.log(`Feed type: ${isAtom ? \"Atom\" : isRss ? \"RSS\" : \"Unknown\"}`);\n\nif (isAtom) {\n  // Parse Atom feed\n  const entryRegex = /<entry[^>]*>[\\s\\S]*?<\\/entry>/gi;\n  let match;\n\n  while ((match = entryRegex.exec(xml)) !== null) {\n    const entryXml = match[0];\n\n    // Extract Atom fields\n    const title = extractTag(entryXml, \"title\");\n    const linkMatch = entryXml.match(/<link[^>]*href=\"([^\"]*)\"[^>]*\\/?>/);\n    const link = linkMatch ? linkMatch[1] : \"\";\n    const content =\n      extractTag(entryXml, \"content\") || extractTag(entryXml, \"summary\") || \"\";\n    const updated = extractTag(entryXml, \"updated\");\n    const id = extractTag(entryXml, \"id\");\n\n    if (!title || !link) continue;\n\n    // Clean content and create description\n    const cleanContent = cleanText(content);\n    const description = cleanContent.slice(0, 800);\n\n    // Convert updated date to publishedAt\n    const publishedAt = updated\n      ? new Date(updated).toISOString()\n      : new Date().toISOString();\n\n    items.push({\n      json: {\n        // Feed metadata\n        sourceName: $(\"Loop Feeds\").item.json.sourceName,\n        sourceId: $(\"Loop Feeds\").item.json.id || \"unknown\",\n        feedUrl: $(\"Loop Feeds\").item.json.feedUrl,\n\n        // Article fields\n        title: cleanText(title),\n        link: link,\n        description: description,\n        guid: id || link,\n        author: extractTag(entryXml, \"name\") || \"Unknown\",\n        category: extractTag(entryXml, \"category\") || \"General\",\n        publishedAt: publishedAt,\n        scrapedAt: new Date().toISOString(),\n\n        // Quality signals\n        sourcePriorityMultiplier: $(\"Loop Feeds\").item.json.priorityMultiplier,\n        wordCount: cleanContent\n          ? cleanContent.split(/\\s+/).filter(Boolean).length\n          : 0,\n        feedType: \"atom\",\n      },\n    });\n  }\n} else if (isRss) {\n  // Parse RSS feed\n  const itemRegex = /<item[\\s\\S]*?<\\/item>/gi;\n  let match;\n\n  while ((match = itemRegex.exec(xml)) !== null) {\n    const block = match[0];\n\n    const title = extractTag(block, \"title\");\n    const link = extractTag(block, \"link\") || extractTag(block, \"guid\");\n    if (!title || !link) continue;\n\n    const body =\n      extractTag(block, \"content:encoded\") ||\n      extractTag(block, \"description\") ||\n      \"\";\n    const description = cleanText(body).slice(0, 800);\n\n    const pubDate =\n      extractTag(block, \"pubDate\") || extractTag(block, \"published\");\n    const publishedAt = pubDate\n      ? new Date(pubDate).toISOString()\n      : new Date().toISOString();\n\n    items.push({\n      json: {\n        // Feed metadata\n        sourceName: $(\"Loop Feeds\").item.json.sourceName,\n        sourceId: $(\"Loop Feeds\").item.json.id || \"unknown\",\n        feedUrl: $(\"Loop Feeds\").item.json.feedUrl,\n\n        // Article fields\n        title: cleanText(title),\n        link: link,\n        description: description,\n        guid: extractTag(block, \"guid\") || link,\n        author:\n          extractTag(block, \"dc:creator\") ||\n          extractTag(block, \"author\") ||\n          \"Unknown\",\n        category: extractTag(block, \"category\") || \"General\",\n        publishedAt: publishedAt,\n        scrapedAt: new Date().toISOString(),\n\n        // Quality signals\n        wordCount: body\n          ? cleanText(body).split(/\\s+/).filter(Boolean).length\n          : 0,\n        feedType: \"rss\",\n      },\n    });\n  }\n}\n\n// Helper function to extract tag content\nfunction extractTag(xml, tagName) {\n  const regex = new RegExp(`<${tagName}[^>]*>([\\\\s\\\\S]*?)<\\\\/${tagName}>`, \"i\");\n  const match = xml.match(regex);\n  return match ? match[1] : \"\";\n}\n\n// Enhanced function to completely remove HTML and clean text\nfunction cleanText(text) {\n  if (typeof text !== \"string\" || !text) return \"\";\n\n  let cleaned = text;\n\n  // Remove CDATA sections first\n  cleaned = cleaned.replace(/<!\\[CDATA\\[([\\s\\S]*?)\\]\\]>/g, \"$1\");\n\n  // Remove HTML comments\n  cleaned = cleaned.replace(/<!--[\\s\\S]*?-->/g, \"\");\n\n  // Remove script, style, and other unwanted tags completely\n  cleaned = cleaned.replace(\n    /<(script|style|noscript|iframe|object|embed|form|input|button)[^>]*>[\\s\\S]*?<\\/\\1>/gi,\n    \"\"\n  );\n\n  // Remove self-closing tags\n  cleaned = cleaned.replace(\n    /<(img|br|hr|input|meta|link|area|base|col|source|track|wbr)[^>]*\\/?>/gi,\n    \" \"\n  );\n\n  // Remove ALL HTML tags - be very aggressive\n  cleaned = cleaned.replace(/<\\/?[^>]*>/g, \" \");\n\n  // Remove any remaining < or > characters\n  cleaned = cleaned.replace(/[<>]/g, \"\");\n\n  // Decode HTML entities - comprehensive list\n  const entities = {\n    \"&amp;\": \"&\",\n    \"&lt;\": \"<\",\n    \"&gt;\": \">\",\n    \"&quot;\": '\"',\n    \"&#39;\": \"'\",\n    \"&apos;\": \"'\",\n    \"&nbsp;\": \" \",\n    \"&copy;\": \"©\",\n    \"&reg;\": \"®\",\n    \"&trade;\": \"™\",\n    \"&hellip;\": \"...\",\n    \"&mdash;\": \"—\",\n    \"&ndash;\": \"—\",\n    \"&lsquo;\": \"'\",\n    \"&rsquo;\": \"'\",\n    \"&ldquo;\": '\"',\n    \"&rdquo;\": '\"',\n    \"&bull;\": \"•\",\n    \"&middot;\": \"·\",\n    \"&sect;\": \"§\",\n    \"&para;\": \"¶\",\n    \"&dagger;\": \"†\",\n    \"&Dagger;\": \"‡\",\n    \"&permil;\": \"‰\",\n    \"&lsaquo;\": \"‹\",\n    \"&rsaquo;\": \"›\",\n    \"&euro;\": \"€\",\n    \"&pound;\": \"£\",\n    \"&yen;\": \"¥\",\n    \"&cent;\": \"¢\",\n  };\n\n  // Replace known entities\n  for (const [entity, replacement] of Object.entries(entities)) {\n    cleaned = cleaned.replace(new RegExp(entity, \"gi\"), replacement);\n  }\n\n  // Handle numeric entities (decimal)\n  cleaned = cleaned.replace(/&#(\\d+);/g, (match, num) => {\n    const code = parseInt(num, 10);\n    if (code >= 32 && code <= 126) return String.fromCharCode(code);\n    if (code === 8217) return \"'\"; // Right single quotation mark\n    if (code === 8216) return \"'\"; // Left single quotation mark\n    if (code === 8220) return '\"'; // Left double quotation mark\n    if (code === 8221) return '\"'; // Right double quotation mark\n    if (code === 8211) return \"—\"; // En dash\n    if (code === 8212) return \"—\"; // Em dash\n    if (code === 8230) return \"...\"; // Horizontal ellipsis\n    return \" \";\n  });\n\n  // Handle hexadecimal entities\n  cleaned = cleaned.replace(/&#x([0-9a-f]+);/gi, (match, hex) => {\n    const code = parseInt(hex, 16);\n    if (code >= 32 && code <= 126) return String.fromCharCode(code);\n    return \" \";\n  });\n\n  // Remove any remaining HTML entities\n  cleaned = cleaned.replace(/&[a-zA-Z][a-zA-Z0-9]{1,30};/g, \" \");\n\n  // Remove URLs that might be embedded\n  cleaned = cleaned.replace(/https?:\\/\\/[^\\s]+/g, \"\");\n  cleaned = cleaned.replace(/www\\.[^\\s]+/g, \"\");\n\n  // Remove email addresses\n  cleaned = cleaned.replace(\n    /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}/g,\n    \"\"\n  );\n\n  // Remove common leftover HTML-like fragments\n  cleaned = cleaned.replace(\n    /^\\s*(img src|href|class|id|style|alt|title|width|height|src)\\s*.*$/gm,\n    \"\"\n  );\n\n  // Remove standalone attribute-like strings\n  cleaned = cleaned.replace(\n    /\\b(src|href|alt|title|class|id|width|height|style)=[\"'][^\"']*[\"']/gi,\n    \"\"\n  );\n\n  // Remove multiple consecutive punctuation\n  cleaned = cleaned.replace(/[.]{3,}/g, \"...\");\n  cleaned = cleaned.replace(/[!]{2,}/g, \"!\");\n  cleaned = cleaned.replace(/[?]{2,}/g, \"?\");\n\n  // Aggressive whitespace normalization\n  cleaned = cleaned.replace(/\\s+/g, \" \");\n\n  // Remove control and non-printable characters\n  cleaned = cleaned.replace(\n    /[\\u0000-\\u001F\\u007F-\\u009F\\u2000-\\u200F\\uFEFF]/g,\n    \"\"\n  );\n\n  // Remove leading/trailing punctuation that might be artifacts\n  cleaned = cleaned.replace(/^[^\\w\\s]+|[^\\w\\s.!?]+$/g, \"\");\n\n  return cleaned.trim();\n}\n\nconsole.log(\n  `Successfully parsed ${items.length} articles from ${\n    isAtom ? \"Atom\" : \"RSS\"\n  } feed`\n);\n\nreturn items;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [720, 704],
      "id": "baca3a91-0657-4616-8f46-2e0bdcd107cf",
      "name": "Parse RSS",
      "alwaysOutputData": true,
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// Stores parsed articles in workflow static data for accumulation across feed iterations\n// Preserves articles between loop executions until collection phase\nconst s = $getWorkflowStaticData(\"global\");\nif (!s.articles) s.articles = [];\nconst inItems = $input.all();\nfor (const it of inItems) {\n  if (it.json?.title && it.json?.link) s.articles.push(it.json);\n}\nreturn inItems;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [944, 704],
      "id": "ce4992e8-4f0e-47da-b67b-86b9e215cd86",
      "name": "Store Articles (Static)"
    },
    {
      "parameters": {
        "jsCode": "// Collects all articles accumulated during the feed loop from workflow static storage\n// Clears the static storage and returns articles for downstream processing\nconst s = $getWorkflowStaticData(\"global\");\nconst all = (s.articles || []).map((a) => ({ json: a }));\ns.articles = [];\nreturn all;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [272, 432],
      "id": "5d24f9a1-7df9-42d6-a9ec-db51886c362a",
      "name": "Accumulate All Articles"
    },
    {
      "parameters": {
        "resource": "databasePage",
        "operation": "getAll",
        "databaseId": {
          "__rl": true,
          "value": "https://www.notion.so/9d899a561818444f8de1d7bd72ee1528?v=25390f46679580bcb9bc000cc4a3bf1e",
          "mode": "url"
        },
        "returnAll": true,
        "simple": false,
        "filterType": "manual",
        "matchType": "allFilters",
        "filters": {
          "conditions": [
            {
              "key": "Created Date|created_time",
              "condition": "on_or_after",
              "createdTimeValue": "={{ new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0] }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.notion",
      "typeVersion": 2.2,
      "position": [496, 432],
      "id": "4c375db6-c660-491d-89e5-256a4c75ed94",
      "name": "Get Recent Articles",
      "alwaysOutputData": true,
      "executeOnce": true,
      "credentials": {
        "notionApi": {
          "id": "lC4G957VFihVvFG2",
          "name": "Notion account"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// Deduplicates articles by comparing against existing Notion database entries\n// Filters out articles with matching titles to prevent duplicate content storage\n\n// Gather existing Notion titles (normalized), excluding trashed/archived\nconst notionPages = ($items(\"Get Recent Articles\", 0) || []).filter(\n  (p) => p?.json?.in_trash !== true && p?.json?.archived !== true\n);\n\nfunction normalized(str) {\n  return (str || \"\").toString().replace(/\\s+/g, \" \").trim().toLowerCase();\n}\n\nfunction getNotionTitle(page) {\n  // raw API shape\n  const t1 = page?.json?.properties?.Title?.title;\n  const titlePlain = Array.isArray(t1)\n    ? t1\n        .map((x) => x?.plain_text || \"\")\n        .join(\" \")\n        .trim()\n    : \"\";\n  if (titlePlain) return titlePlain;\n\n  // simplified or fallback shapes\n  return page?.json?.Title || page?.json?.title || \"\";\n}\n\nconst existingTitleSet = new Set(\n  notionPages.map(getNotionTitle).map(normalized).filter(Boolean)\n);\n\n// New articles from Accumulate\nconst newArticles = $items(\"Accumulate All Articles\", 0) || [];\n\nconst uniques = [];\nfor (const it of newArticles) {\n  const title = normalized(it?.json?.title || it?.json?.Title);\n  if (!title) continue;\n  if (existingTitleSet.has(title)) continue; // duplicate → skip\n  uniques.push(it);\n}\n\nreturn uniques;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [720, 432],
      "id": "4ece84e3-9c08-44f5-903d-06eed1a863a2",
      "name": "Remove Duplicates"
    },
    {
      "parameters": {
        "jsCode": "// Filters articles based on quality signals, source priority, and recency\n// Uses source-specific age limits and scoring to reduce noise whilst preserving valuable content\n\nconst MIN_COMBINED_WORDS = 10;\nconst MIN_TITLE_LEN = 40;\n\n// Different age limits based on source quality\nconst SOURCE_AGE_LIMITS = {\n  // Premium sources - content stays relevant longer\n  \"Martin Fowler's Blog\": 90, // 3 months - his content is timeless\n  \"Stripe Engineering Blog\": 60,\n  \"Netflix Tech Blog\": 60,\n  \"Google Cloud Blog\": 45,\n  \"AWS Architecture Blog\": 45,\n  \"Thoughtworks Technology Radar\": 90,\n  \"First Round Review\": 60,\n  \"Lenny's Newsletter\": 30,\n  InfoQ: 45,\n  Stratechery: 30,\n\n  // Default for most sources\n  Default: 30, // Increased from 21 to 30 days\n};\n\n// Source priority multipliers based on content focus\nconst SOURCE_PRIORITY_MULTIPLIERS = {\n  // Funding-heavy sources (lower priority)\n  TechEU: 0.7,\n  \"TechCrunch Europe\": 0.8,\n  Sifted: 0.8,\n  SwissStartups: 0.7,\n  \"EU-Startups\": 0.7,\n\n  // High-value technical/strategic sources\n  \"Stripe Engineering Blog\": 1.5,\n  \"Netflix Tech Blog\": 1.5,\n  \"Google Cloud Blog\": 1.5,\n  \"AWS Architecture Blog\": 1.5,\n  \"Thoughtworks Technology Radar\": 1.5,\n  \"First Round Review\": 1.5,\n  \"Lenny's Newsletter\": 1.5,\n  \"Martin Fowler's Blog\": 1.5,\n  InfoQ: 1.5,\n  Stratechery: 1.3,\n  \"MIT Technology Review\": 1.2,\n  \"Harvard Business Review Management\": 1.3,\n  \"Andreessen Horowitz (a16z)\": 1.2,\n  \"Y Combinator Blog\": 1.2,\n  \"High Growth Engineering\": 1.2,\n\n  // Medium priority sources\n  \"The New Stack\": 1.0,\n  \"Ars Technica\": 1.0,\n\n  // Default for unknown sources\n  Default: 1.0,\n};\n\n// Keywords that indicate high-value content for tech leaders\nconst HIGH_VALUE_KEYWORDS = [\n  \"ai\",\n  \"artificial intelligence\",\n  \"agentic\",\n  \"model\",\n  \"models\",\n  \"compute\",\n  \"gpu\",\n  \"architecture\",\n  \"scaling\",\n  \"performance\",\n  \"optimisation\",\n  \"framework\",\n  \"pattern\",\n  \"leadership\",\n  \"management\",\n  \"strategy\",\n  \"culture\",\n  \"hiring\",\n  \"team\",\n  \"platform\",\n  \"compliance\",\n  \"security\",\n  \"cyber\",\n  \"cloud\",\n  \"open-source\",\n  \"startup\",\n  \"scale-up\",\n  \"supercomputer\",\n  \"sovereign\",\n  \"quantum\",\n  \"benchmark\",\n  \"llm\",\n];\n\n// Keywords that indicate low-value content (funding noise)\nconst LOW_VALUE_KEYWORDS = [\n  \"job opening\",\n  \"we are hiring\",\n  \"webinar\",\n  \"podcast\",\n  \"event\",\n  \"conference\",\n  \"newsletter\",\n  \"roundup\",\n  \"sponsored\",\n  \"advertorial\",\n  \"press release\",\n];\n\nfunction normalize(str) {\n  return (str || \"\").toString().replace(/\\s+/g, \" \").trim();\n}\n\nfunction lower(str) {\n  return normalize(str).toLowerCase();\n}\n\nfunction wordsCount(str) {\n  return normalize(str).split(/\\s+/).filter(Boolean).length;\n}\n\nfunction hasAny(text, list) {\n  const t = lower(text);\n  return list.some((k) => t.includes(k));\n}\n\nfunction daysSince(dateIso) {\n  const t = Date.parse(dateIso);\n  if (!Number.isFinite(t)) return Infinity;\n  return (Date.now() - t) / 86400000;\n}\n\nfunction calculateArticleScore(article, sourceName) {\n  // Get multiplier from article's source data (passed from Notion)\n  const priorityMultiplier = article.sourcePriorityMultiplier || 1.0;\n\n  let score = 0;\n\n  // Body richness (prefer content:encoded-derived wordCount)\n  const bodyWords = article.wordCount || 0;\n  if (bodyWords >= 400) score += 3;\n  else if (bodyWords >= 250) score += 2;\n  else if (bodyWords >= 120) score += 1;\n\n  // Headline/teaser substance\n  const combined = `${article.title} ${article.description}`;\n  const combinedWords = wordsCount(combined);\n  if (combinedWords >= MIN_COMBINED_WORDS) score += 1;\n\n  // Title strength\n  if (article.title && article.title.length >= MIN_TITLE_LEN) score += 1;\n\n  // High-value keyword signals (multiple hits add more weight)\n  const highValueHits = HIGH_VALUE_KEYWORDS.filter((kw) =>\n    lower(combined).includes(kw)\n  ).length;\n  if (highValueHits >= 3) score += 2;\n  else if (highValueHits >= 1) score += 1;\n\n  // Recency bonus (but don't penalize quality sources too much)\n  const age = article.publishedAt ? daysSince(article.publishedAt) : Infinity;\n  if (age <= 3) score += 2;\n  else if (age <= 7) score += 1;\n  else if (age <= 14 && priorityMultiplier >= 1.3) score += 1; // Bonus for high-priority sources even if older\n\n  // Apply source priority multiplier\n  score = Math.round(score * priorityMultiplier);\n\n  return score;\n}\n\nfunction getBodyText(article) {\n  // Prefer parser-provided clean body if available (from content:encoded)\n  const body = article.contentEncodedClean || article.body || \"\";\n  if (body) return body;\n\n  // Fallback to description (teaser)\n  return article.description || \"\";\n}\n\n// Lightweight in-flow de-duplication by guid/link/title\nconst seen = new Set();\n\nconst out = [];\nlet filteredByAge = 0;\nlet filteredByLowValue = 0;\nlet filteredByThreshold = 0;\n\nfor (const it of $input.all()) {\n  const j = it?.json || {};\n  const title = normalize(j.title);\n  const link = normalize(j.link);\n  if (!title || !link) continue;\n\n  // Local de-dupe key (within this node's run)\n  const key = `${lower(title)}|${lower(link)}`;\n  if (seen.has(key)) continue;\n  seen.add(key);\n\n  // Get age limit for this source\n  const ageLimit =\n    SOURCE_AGE_LIMITS[j.sourceName] || SOURCE_AGE_LIMITS[\"Default\"];\n\n  // Recency filter with source-specific limits\n  if (j.publishedAt) {\n    const age = daysSince(j.publishedAt);\n    if (age > ageLimit) {\n      filteredByAge++;\n      console.log(\n        `❌ Too old for ${\n          j.sourceName\n        } (${ageLimit}d limit): \"${title.substring(0, 40)}...\" (${age.toFixed(\n          1\n        )} days)`\n      );\n      continue;\n    }\n  }\n\n  const combined = `${title} ${normalize(j.description)}`;\n\n  // Fast negative filter on obvious low-signal content\n  if (hasAny(combined, LOW_VALUE_KEYWORDS)) {\n    filteredByLowValue++;\n    continue;\n  }\n\n  // Calculate score with source priority\n  const score = calculateArticleScore(j, j.sourceName);\n\n  // Dynamic threshold based on source priority\n  const baseThreshold = 2;\n  const sourceMultiplier =\n    SOURCE_PRIORITY_MULTIPLIERS[j.sourceName] ||\n    SOURCE_PRIORITY_MULTIPLIERS[\"Default\"];\n  const threshold =\n    sourceMultiplier < 1.0 ? Math.max(baseThreshold + 1, 3) : baseThreshold;\n\n  // Hard includes: strong signals even if body is short\n  const hardInclude =\n    /\\b(raises|raised|acquire|acquisition|series [abc]|seed|pre-seed)\\b/i.test(\n      combined\n    ) || /\\b(series\\s?[abc])\\b/i.test(combined);\n\n  if (hardInclude || score >= threshold) {\n    // Add source priority info for debugging\n    const enhancedArticle = {\n      ...j,\n      _sourcePriority: sourceMultiplier,\n      _articleScore: score,\n      _threshold: threshold,\n      _ageLimit: ageLimit,\n    };\n\n    out.push({ json: enhancedArticle });\n  } else {\n    filteredByThreshold++;\n  }\n}\n\nconsole.log(\n  `Pre-filtered ${out.length} articles from ${\n    $input.all().length\n  } input articles`\n);\nconsole.log(\n  `Filtered: Age=${filteredByAge}, LowValue=${filteredByLowValue}, BelowThreshold=${filteredByThreshold}`\n);\n\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [944, 432],
      "id": "7a93849d-c0d3-4ad7-aa24-8140c5202762",
      "name": "Pre-filter"
    },
    {
      "parameters": {
        "jsCode": "// Make AI Batches: robust batching + tight prompt for structured JSON\n// - Keeps batch size 5 (safe for token limits with short bodies)\n// - Uses cleaned body if available; otherwise description\n// - Adds strict instructions (no prose/markdown, exact array length, ordered mapping)\n// - Includes per-item ids to aid downstream alignment\n// - Escapes quotes/newlines; trims long text\n\nconst DEFAULT_BATCH_SIZE = 5;\nconst MAX_SNIPPET_CHARS = 550; // short context keeps tokens bounded\n\nfunction normalize(str) {\n  return (str || \"\").toString().replace(/\\s+/g, \" \").trim();\n}\nfunction clip(str, n) {\n  const s = normalize(str);\n  return s.length > n ? s.slice(0, n) + \"…\" : s;\n}\nfunction escapeForPrompt(str) {\n  return (str || \"\")\n    .replace(/\\\\/g, \"\\\\\\\\\")\n    .replace(/\"/g, '\\\\\"')\n    .replace(/\\n/g, \" \");\n}\nfunction getBody(j) {\n  // Prefer cleaned full body if parser provided; otherwise description\n  const body = j.contentEncodedClean || j.body || j.description || \"\";\n  // Drop any lingering HTML tags\n  const clean = body.replace(/<[^>]*>/g, \" \");\n  return clean;\n}\n\nconst items = $input.all();\nconst batches = [];\n\nfor (let i = 0; i < items.length; i += DEFAULT_BATCH_SIZE) {\n  const batch = items.slice(i, i + DEFAULT_BATCH_SIZE);\n\n  // Build per-article lines with stable index (1-based within batch)\n  const lines = batch\n    .map((it, idx) => {\n      const a = it.json || {};\n      const title = escapeForPrompt(normalize(a.title));\n      const link = normalize(a.link);\n      const cat = normalize(a.category || \"General\");\n      const pub = normalize(a.publishedAt || \"Unknown\");\n\n      const body = getBody(a);\n      const snippet = escapeForPrompt(clip(body, MAX_SNIPPET_CHARS));\n      const teaser = escapeForPrompt(clip(a.description || \"\", 280));\n\n      // Use both snippet and teaser; snippet first (higher signal)\n      return `${idx + 1}. id=${idx + 1}\nTitle: \"${title}\"\nLink: ${link}\nCategory: ${cat}\nPublished: ${pub}\nBody: \"${snippet}\"\nTeaser: \"${teaser}\"`;\n    })\n    .join(\"\\n\\n\");\n\n  const prompt = `You are classifying tech articles for the editorial backlog at xavierFuentes.com (audience: CTOs, EMs, tech leaders, PMs, founders, VCs in the UK and Europe).\nReturn ONLY a JSON array (no markdown, no prose). The array MUST have exactly ${batch.length} objects, in the SAME ORDER as the input (1..${batch.length}).\nEach object corresponds to the item with the same id.\nIMPORTANT: Write all output in UK English (e.g., organisation not organization, analyse not analyze, optimisation not optimization).\n\nInclude all fields and ensure every score is an integer 1..10 (no nulls).\nIf an article is irrelevant, still include it with priority \"Low\" and low scores.\nIf information is missing, infer conservatively.\n\nAllowed enums:\n- content_pillar: \"Market & Trends\" | \"Leadership & Management\" | \"Technology Strategy\" | \"Execution & Delivery\" | \"Founder Lessons\" | \"Personal Angle\"\n- priority: \"High\" | \"Medium\" | \"Low\"\n- target_audience (subset): [\"CTOs\",\"Engineering Managers\",\"Tech Leaders\",\"Product Managers\",\"Founders\",\"VCs & Investors\",\"Scale-up Leaders\"]\n- word_count_target: one of 400, 600, 900\n\nScoring rubrics (use 1..10 integers):\n- relevance_score: how aligned to the chosen audience and content_pillar.\n  1-3 = marginal/tenuous; 4-6 = moderately relevant; 7-8 = strong; 9-10 = must-cover.\n- actionability_score: presence of concrete takeaways, decisions, frameworks, or steps.\n  1-3 = mostly newsy; 4-6 = some takeaways; 7-8 = clear actions; 9-10 = highly actionable.\n- depth_score: technical/analytical substance (data, architecture, trade-offs, rigorous analysis).\n  1-3 = surface-level; 4-6 = moderate depth; 7-8 = solid depth; 9-10 = deep/rigorous.\n\nNotes field:\n- \"notes\" should be 1-3 concise sentences advising how to angle the article for the chosen target_audience\n  (e.g., organisational framing for EMs, architectural implications for CTOs, market signals for VCs).\n- Avoid generic advice; tie to the article's specifics.\n- Write notes in UK English with proper British spelling and terminology.\n\nSCHEMA (each object):\n{\n  \"id\": number,                  // 1..${batch.length} from input\n  \"title\": string,               // unchanged\n  \"link\": string,                // unchanged\n  \"content_pillar\": string,      // enum\n  \"priority\": string,            // enum\n  \"target_audience\": string[],   // 1-3 from allowed list\n  \"word_count_target\": number,   // 400 | 600 | 900\n  \"seo_keywords\": string,        // 3-6 comma-separated terms\n  \"description\": string,         // 1 sentence (<= 24 words)\n  \"notes\": string,               // 1-3 sentences: how to angle for the chosen audience\n  \"relevance_score\": number,     // 1..10 (int)\n  \"actionability_score\": number, // 1..10 (int)\n  \"depth_score\": number          // 1..10 (int)\n}\n\nConstraints:\n- Output must be valid JSON (UTF-8), no markdown, no backticks, no comments, no trailing commas.\n- Keep titles and links exactly as provided; do not rewrite.\n- Do not drop items; if weak, set priority \"Low\" with low scores and explain briefly in \"notes\".\n- Align each object’s \"id\" to the corresponding input id.\n- Prefer \"Market & Trends\" for funding/market moves; \"Leadership & Management\" for organisation/process/people; \"Technology Strategy\" for architecture/infrastructure/ML/compute; \"Execution & Delivery\" for practices/tooling; \"Founder Lessons\" for founder narratives; \"Personal Angle\" sparingly.\n\nARTICLES:\n${lines}\n\nReturn ONLY the JSON array.`;\n\n  batches.push({\n    json: {\n      batchPrompt: prompt,\n      batchArticles: batch.map((x) => x.json),\n      batchSize: batch.length,\n    },\n  });\n}\n\nreturn batches;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1168, 432],
      "id": "9c54a275-9411-4bbc-9e6d-386aaa493a11",
      "name": "Make AI Batches"
    },
    {
      "parameters": {
        "modelId": {
          "__rl": true,
          "value": "claude-3-haiku-20240307",
          "mode": "list",
          "cachedResultName": "claude-3-haiku-20240307"
        },
        "messages": {
          "values": [
            {
              "content": "={{ $json.batchPrompt }}"
            }
          ]
        },
        "options": {
          "maxTokens": 2000
        }
      },
      "type": "@n8n/n8n-nodes-langchain.anthropic",
      "typeVersion": 1,
      "position": [1392, 432],
      "id": "32135601-b274-4f55-8d32-7a26e6022fec",
      "name": "AI Content Analysis",
      "alwaysOutputData": true,
      "credentials": {
        "anthropicApi": {
          "id": "yRaXinQhqHkgqzEg",
          "name": "Anthropic account"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// Merges AI classification results from batches into individual article items\n// Normalises AI outputs and prepares data for Notion database storage\n\nconst allAi = $input.all(); // e.g., 4 items (one per batch)\nconst batches = $items(\"Make AI Batches\", 0) || []; // original batches from batching node\n\nconst validPillars = [\n  \"Leadership & Management\",\n  \"Technology Strategy\",\n  \"Execution & Delivery\",\n  \"Founder Lessons\",\n  \"Market & Trends\",\n  \"Personal Angle\",\n];\nconst normPillar = (p) => {\n  if (typeof p === \"string\") {\n    const exact = validPillars.find((v) => v === p.trim());\n    if (exact) return exact;\n    const lower = p.toLowerCase();\n    const fuzzy = validPillars.find(\n      (v) => v.toLowerCase().includes(lower) || lower.includes(v.toLowerCase())\n    );\n    if (fuzzy) return fuzzy;\n  }\n  return \"Market & Trends\";\n};\nconst normPriority = (p) => {\n  const s = String(p || \"Medium\").toLowerCase();\n  return s === \"high\" ? \"High\" : s === \"low\" ? \"Low\" : \"Medium\";\n};\nconst clamp10 = (v, d = 5) => {\n  const n = Number(v);\n  const i = Number.isFinite(n) ? Math.round(n) : d;\n  return Math.max(1, Math.min(10, i));\n};\nconst normalizeKeywords = (k) =>\n  String(k || \"\")\n    .split(\",\")\n    .map((s) => s.trim())\n    .filter(Boolean)\n    .slice(0, 8)\n    .join(\", \")\n    .toLowerCase();\nconst allowedWordTargets = new Set([400, 600, 900]);\nconst normWordTarget = (n) =>\n  allowedWordTargets.has(Number(n)) ? Number(n) : 600;\nconst limitAudience = (a) =>\n  Array.isArray(a) && a.length ? a.slice(0, 3) : [\"Tech Leaders\"];\n\nfunction parseAiArray(text) {\n  try {\n    let cleaned = (text || \"\")\n      .replace(/```json/g, \"\")\n      .replace(/```/g, \"\")\n      .trim();\n    const s = cleaned.indexOf(\"[\"),\n      e = cleaned.lastIndexOf(\"]\");\n    if (s !== -1 && e !== -1) cleaned = cleaned.slice(s, e + 1);\n    const parsed = JSON.parse(cleaned);\n    return Array.isArray(parsed) ? parsed : [parsed];\n  } catch {\n    return null;\n  }\n}\n\nconst out = [];\nfor (let k = 0; k < allAi.length; k++) {\n  const ai = allAi[k]?.json || {};\n  const batch = batches[k]?.json;\n  if (!batch) continue;\n\n  const aiText = ai?.content?.[0]?.text || ai?.text || \"\";\n  let classifications = parseAiArray(aiText);\n\n  if (\n    !classifications ||\n    classifications.length !== batch.batchArticles.length\n  ) {\n    console.log(\n      `AI parsing failed for batch ${k}, generating intelligent fallbacks`\n    );\n\n    classifications = batch.batchArticles.map((a, idx) => {\n      // Use the actual article description, properly cleaned\n      const cleanDesc = (a.description || \"\")\n        .replace(/<[^>]*>/g, \" \")\n        .replace(/\\s+/g, \" \")\n        .trim();\n      const shortDesc =\n        cleanDesc.length > 120 ? cleanDesc.slice(0, 120) + \"...\" : cleanDesc;\n\n      // Smart content analysis for better fallbacks\n      const title = (a.title || \"\").toLowerCase();\n      const description = cleanDesc.toLowerCase();\n      const combined = `${title} ${description}`;\n      const sourceName = (a.sourceName || \"\").toLowerCase();\n\n      // Intelligent content pillar detection\n      let contentPillar = \"Market & Trends\"; // default\n      if (\n        combined.match(\n          /\\b(leadership|management|team|culture|hiring|organization)\\b/\n        )\n      ) {\n        contentPillar = \"Leadership & Management\";\n      } else if (\n        combined.match(\n          /\\b(architecture|performance|security|infrastructure|cloud|api|database|scaling)\\b/\n        )\n      ) {\n        contentPillar = \"Technology Strategy\";\n      } else if (\n        combined.match(\n          /\\b(agile|devops|testing|deployment|process|methodology|framework)\\b/\n        )\n      ) {\n        contentPillar = \"Execution & Delivery\";\n      } else if (\n        combined.match(\n          /\\b(founder|startup|entrepreneur|funding|venture|seed|series)\\b/\n        )\n      ) {\n        contentPillar = \"Founder Lessons\";\n      }\n\n      // Generate relevant keywords based on content\n      const potentialKeywords = [];\n      const keywordMap = {\n        \"ai|artificial intelligence|machine learning|ml\": \"ai\",\n        \"cloud|aws|azure|gcp\": \"cloud computing\",\n        \"security|cybersecurity|vulnerability\": \"security\",\n        \"performance|optimization|scalability\": \"performance\",\n        \"leadership|management\": \"leadership\",\n        \"startup|entrepreneur\": \"startups\",\n        \"development|programming|coding\": \"software development\",\n        \"api|microservices|architecture\": \"software architecture\",\n      };\n\n      for (const [pattern, keyword] of Object.entries(keywordMap)) {\n        if (new RegExp(pattern, \"i\").test(combined)) {\n          potentialKeywords.push(keyword);\n        }\n      }\n\n      // Fallback keywords if none found\n      if (potentialKeywords.length === 0) {\n        potentialKeywords.push(\"technology\", \"innovation\");\n      }\n\n      // Smart priority based on source quality and content\n      let priority = \"Medium\";\n      if (\n        sourceName.match(/martin fowler|stripe|netflix|google|aws|thoughtworks/)\n      ) {\n        priority = \"High\";\n      } else if (\n        combined.match(/\\b(funding|raised|investment|acquired|ipo)\\b/) &&\n        !combined.match(/\\b(strategy|technology|innovation)\\b/)\n      ) {\n        priority = \"Low\";\n      }\n\n      // Better audience targeting\n      const audience = [\"Tech Leaders\"];\n      if (combined.match(/\\b(cto|engineering manager|technical director)\\b/)) {\n        audience.push(\"CTOs\", \"Engineering Managers\");\n      } else if (combined.match(/\\b(founder|ceo|startup)\\b/)) {\n        audience.push(\"Founders\");\n      } else if (combined.match(/\\b(product|pm|product manager)\\b/)) {\n        audience.push(\"Product Managers\");\n      }\n\n      // Generate meaningful notes instead of \"Fallback\"\n      const notes = `Article covers ${contentPillar.toLowerCase()} topics. ${\n        sourceName ? `Source: ${sourceName}. ` : \"\"\n      }Content appears relevant for ${audience.join(\", \").toLowerCase()}.`;\n\n      return {\n        id: idx + 1,\n        title: a.title,\n        link: a.link,\n        content_pillar: contentPillar,\n        priority: priority,\n        target_audience: audience.slice(0, 3),\n        word_count_target: 600,\n        seo_keywords: potentialKeywords.slice(0, 4).join(\", \"),\n        description: shortDesc || \"Article summary not available\",\n        notes: notes,\n        relevance_score: 6,\n        actionability_score: 5,\n        depth_score: 5,\n      };\n    });\n  }\n\n  for (let i = 0; i < batch.batchArticles.length; i++) {\n    const a = batch.batchArticles[i] || {};\n    const c = classifications[i] || {};\n\n    out.push({\n      json: {\n        sourceName: a.sourceName,\n        sourceId: a.sourceId,\n        feedUrl: a.feedUrl,\n        title: a.title,\n        link: a.link,\n        description: a.description,\n        guid: a.guid || a.link,\n        author: a.author,\n        category: a.category,\n        publishedAt: a.publishedAt,\n        scrapedAt: a.scrapedAt,\n        wordCount: a.wordCount,\n\n        property_title: a.title,\n        property_description: a.description,\n        property_author: a.author,\n        property_source: a.sourceName,\n        property_article_link: a.link,\n        property_guid: a.guid || a.link,\n        property_content_pillar: normPillar(c.content_pillar),\n        property_priority: normPriority(c.priority),\n        property_target_audience: limitAudience(c.target_audience),\n        property_word_count_target: normWordTarget(c.word_count_target),\n        property_seo_keywords: normalizeKeywords(c.seo_keywords),\n        property_relevance_score: clamp10(c.relevance_score, 5),\n        property_actionability_score: clamp10(c.actionability_score, 5),\n        property_depth_score: clamp10(c.depth_score, 5),\n        property_status: \"Research\",\n        property_notes: (c.notes || \"\").toString().trim().slice(0, 1000),\n\n        processed_at: new Date().toISOString(),\n      },\n    });\n  }\n}\n\nreturn out;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1744, 432],
      "id": "1919c17d-5a4a-4527-83c7-1a6d6eeb7985",
      "name": "Merge Batch Results"
    },
    {
      "parameters": {
        "resource": "databasePage",
        "databaseId": {
          "__rl": true,
          "value": "https://www.notion.so/9d899a561818444f8de1d7bd72ee1528?v=25090f46679580679c2b000c6016836d&source=copy_link",
          "mode": "url"
        },
        "title": "={{ $json.property_title }}",
        "propertiesUi": {
          "propertyValues": [
            {
              "key": "Content Pillar|select",
              "selectValue": "={{ $json.property_content_pillar }}"
            },
            {
              "key": "Target Audience|multi_select",
              "multiSelectValue": "={{ $json.property_target_audience }}"
            },
            {
              "key": "Priority|select",
              "selectValue": "={{ $json.property_priority }}"
            },
            {
              "key": "Status|select",
              "selectValue": "={{ $json.property_status }}"
            },
            {
              "key": "Article Link|url",
              "urlValue": "={{ $json.property_article_link }}"
            },
            {
              "key": "SEO Keywords|rich_text",
              "textContent": "={{ $json.property_seo_keywords }}"
            },
            {
              "key": "Word Count Target|number",
              "numberValue": "={{ $json.property_word_count_target }}"
            },
            {
              "key": "Source|rich_text",
              "textContent": "={{ $json.property_source }}"
            },
            {
              "key": "Author|rich_text",
              "textContent": "={{ $json.property_author }}"
            },
            {
              "key": "Description|rich_text",
              "textContent": "={{ $json.property_description }}"
            },
            {
              "key": "GUID|rich_text",
              "textContent": "={{ $json.property_guid }}"
            },
            {
              "key": "Relevance Score|number",
              "numberValue": "={{ $json.property_relevance_score }}"
            },
            {
              "key": "Actionability Score|number",
              "numberValue": "={{ $json.property_actionability_score }}"
            },
            {
              "key": "Depth Score|number",
              "numberValue": "={{ $json.property_depth_score }}"
            },
            {
              "key": "Notes|rich_text",
              "richText": true,
              "text": {
                "text": [
                  {
                    "text": "={{ $json.property_notes }}",
                    "annotationUi": {}
                  }
                ]
              }
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.notion",
      "typeVersion": 2.2,
      "position": [1968, 432],
      "id": "0a84d266-d8bc-48f7-a84e-a6c821b96109",
      "name": "Create Pipeline Entry",
      "credentials": {
        "notionApi": {
          "id": "lC4G957VFihVvFG2",
          "name": "Notion account"
        }
      }
    },
    {
      "parameters": {
        "resource": "databasePage",
        "operation": "update",
        "pageId": {
          "__rl": true,
          "value": "={{ $json.id }}",
          "mode": "id"
        },
        "propertiesUi": {
          "propertyValues": [
            {
              "key": "Last Scraped|date",
              "date": "={{ new Date().toISOString() }}",
              "timezone": "Europe/London"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.notion",
      "typeVersion": 2.2,
      "position": [-432, 640],
      "id": "6400f701-7c49-4de7-8423-50c55145e1b2",
      "name": "Update Last Scraped Date",
      "credentials": {
        "notionApi": {
          "id": "lC4G957VFihVvFG2",
          "name": "Notion account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "7b437afc-71d1-478a-b6e5-5bc2583b8c64",
              "leftValue": "={{ $json.needsNotionUpdate }}",
              "rightValue": "=true",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [1136, 1072],
      "id": "73d039c0-fd71-486c-8524-37a617ab39c2",
      "name": "Need Notion Update?"
    },
    {
      "parameters": {
        "resource": "databasePage",
        "operation": "update",
        "pageId": {
          "__rl": true,
          "value": "={{ $json.id }}",
          "mode": "id"
        },
        "propertiesUi": {
          "propertyValues": [
            {
              "key": "Active|checkbox",
              "checkboxValue": "={{ $json.updateActive }}"
            },
            {
              "key": "API Key Required|checkbox",
              "checkboxValue": "={{ $json.updateApiKeyRequired }}"
            },
            {
              "key": "Error Notes|rich_text",
              "richText": true,
              "text": {
                "text": [
                  {
                    "text": "={{ $json.updateNotes }}",
                    "annotationUi": {}
                  }
                ]
              }
            },
            {
              "key": "Last Error|date",
              "date": "={{ $json.updateLastErrorDate }}",
              "timezone": "Europe/London"
            },
            {
              "key": "Consecutive Failures|number",
              "numberValue": "={{ $json.updateConsecutiveFailures }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.notion",
      "typeVersion": 2.2,
      "position": [1376, 1056],
      "id": "e5e261aa-f28e-4bd0-af12-e4e1a5525d56",
      "name": "Update Source Status",
      "credentials": {
        "notionApi": {
          "id": "lC4G957VFihVvFG2",
          "name": "Notion account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Tracks pipeline execution metrics and generates performance summaries\n  // Monitors article flow, API costs, and source reliability for UK-based content pipeline\n\n  // Collect metrics from the pipeline run\n  const metrics = {\n    // Execution metadata\n    executionId: $execution.id,\n    timestamp: new Date().toISOString(),\n\n    // Source metrics\n    totalSourcesProcessed: $(\"Loop Feeds\").context[\"noItemsLeft\"]\n      ? $(\"Loop Feeds\").context[\"currentRunIndex\"]\n      : 0,\n\n    // Article metrics\n    articlesDownloaded: $(\"Parse RSS\").context?.[\"itemsCount\"] || 0,\n    articlesAfterPrefilter: $(\"Pre-filter\").context?.[\"itemsCount\"] || 0,\n    articlesAfterDedup: $(\"Remove Duplicates\").context?.[\"itemsCount\"] || 0,\n    articlesSentToAI: $(\"Make AI Batches\").context?.[\"itemsCount\"] || 0,\n    articlesStored: $(\"Create Pipeline Entry\").context?.[\"itemsCount\"] || 0,\n\n    // Quality metrics\n    filterRate: 0,\n    dedupRate: 0,\n\n    // API usage estimate (rough)\n    estimatedTokensUsed: 0,\n    estimatedApiCost: 0,\n\n    // Error tracking\n    failedSources: [],\n    errors: [],\n  };\n\n  // Calculate rates\n  if (metrics.articlesDownloaded > 0) {\n    metrics.filterRate = Math.round(\n      ((metrics.articlesDownloaded - metrics.articlesAfterPrefilter) /\n        metrics.articlesDownloaded) *\n        100\n    );\n  }\n\n  if (metrics.articlesAfterPrefilter > 0) {\n    metrics.dedupRate = Math.round(\n      ((metrics.articlesAfterPrefilter - metrics.articlesAfterDedup) /\n        metrics.articlesAfterPrefilter) *\n        100\n    );\n  }\n\n  // Estimate token usage (rough calculation)\n  // Assume ~500 tokens per article for Claude Haiku\n  if (metrics.articlesSentToAI > 0) {\n    metrics.estimatedTokensUsed = metrics.articlesSentToAI * 500;\n    // Claude Haiku pricing: $0.25 per million input tokens\n    metrics.estimatedApiCost = (metrics.estimatedTokensUsed / 1000000) * 0.25;\n  }\n\n  // Check for failed sources from error handling\n  try {\n    const errorData = $(\"RSS Error Handler\").all();\n    if (errorData && errorData.length > 0) {\n      metrics.failedSources = errorData.map((item) => ({\n        source: item.json.sourceName,\n        error: item.json.error,\n        timestamp: item.json.timestamp,\n      }));\n    }\n  } catch (e) {\n    // No errors to report\n  }\n\n  // Generate summary message\n  const summary = `\n  📊 **Pipeline Run Summary**\n  ⏰ ${new Date().toLocaleString('en-GB', { timeZone: 'Europe/London' })}\n\n  **Sources & Articles:**\n  • Sources processed: ${metrics.totalSourcesProcessed}\n  • Articles downloaded: ${metrics.articlesDownloaded}\n  • After pre-filter: ${metrics.articlesAfterPrefilter} (${\n    metrics.filterRate\n  }% filtered)\n  • After dedup: ${metrics.articlesAfterDedup} (${metrics.dedupRate}% duplicates)\n  • Sent to AI: ${metrics.articlesSentToAI}\n  • Stored in Notion: ${metrics.articlesStored}\n\n  **Estimated Costs:**\n  • Tokens used: ~${metrics.estimatedTokensUsed.toLocaleString()}\n  • API cost: ~$${metrics.estimatedApiCost.toFixed(4)}\n\n  ${\n    metrics.failedSources.length > 0\n      ? `**⚠️ Failed Sources:**\\n${metrics.failedSources\n          .map((s) => `• ${s.source}: ${s.error}`)\n          .join(\"\\n\")}`\n      : \"✅ All sources processed successfully\"\n  }\n  `;\n\n  console.log(summary);\n\n  // Store metrics for tracking over time\n  return {\n    json: {\n      metrics,\n      summary,\n      // Add performance indicators\n      performance: {\n        healthy: metrics.failedSources.length === 0 && metrics.articlesStored > 0,\n        efficiency: metrics.filterRate < 90 ? \"good\" : \"too_aggressive\",\n        costPerArticle:\n          metrics.articlesStored > 0\n            ? (metrics.estimatedApiCost / metrics.articlesStored).toFixed(4)\n            : 0,\n      },\n    },\n  };"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2400, 432],
      "id": "80edc9d4-e984-478c-8e6b-2ff05bb3c782",
      "name": "Pipeline Metrics"
    },
    {
      "parameters": {
        "resource": "databasePage",
        "databaseId": {
          "__rl": true,
          "value": "https://www.notion.so/27390f46679580d9bd79c8407e4254d7?v=25390f46679580bcb9bc000cc4a3bf1e&source=copy_link",
          "mode": "url"
        },
        "title": "scrape",
        "propertiesUi": {
          "propertyValues": [{}]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.notion",
      "typeVersion": 2.2,
      "position": [2608, 432],
      "id": "2bf701b9-cb86-4716-a18a-51ebe0b6cb48",
      "name": "Create a database page",
      "credentials": {
        "notionApi": {
          "id": "lC4G957VFihVvFG2",
          "name": "Notion account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Handles RSS feed download errors and tracks consecutive failures\n// Automatically marks sources for deactivation after 5 failures\n\nconst items = [];\n\ntry {\n  // Get current source info from the Loop\n  const currentSource = $(\"Loop Feeds\").item.json;\n  const sourceName =\n    currentSource.sourceName || currentSource.property_source_name || \"Unknown\";\n  const sourceId = currentSource.id;\n\n  console.log(`Processing failed source: ${sourceName} (ID: ${sourceId})`);\n\n  // Get CURRENT failure count from Notion (this is the key!)\n  const currentFailures = currentSource.property_consecutive_failures || 0;\n  const newFailureCount = currentFailures + 1;\n\n  console.log(\n    `Previous failures: ${currentFailures}, New count: ${newFailureCount}`\n  );\n\n  // Analyze the error type from HTTP response\n  const httpResponse = $(\"Download RSS\").item.json;\n  const errorAnalysis = analyzeError(httpResponse);\n\n  console.log(`Error type: ${errorAnalysis.type} - ${errorAnalysis.message}`);\n\n  // Determine if source should be deactivated\n  const shouldDeactivate = newFailureCount >= 5;\n  const needsApiKey = errorAnalysis.needsApiKey;\n\n  if (shouldDeactivate) {\n    console.log(\n      `⚠️ Source ${sourceName} should be DEACTIVATED (${newFailureCount} failures)`\n    );\n  }\n\n  // Create error result with NEW failure count\n  const errorResult = {\n    json: {\n      // Notion page identification\n      id: sourceId,\n      sourceName: sourceName,\n\n      // Updated failure tracking\n      consecutiveFailures: newFailureCount,\n      previousFailures: currentFailures,\n\n      // Error details\n      errorType: errorAnalysis.type,\n      statusCode: errorAnalysis.statusCode,\n      errorMessage: errorAnalysis.message,\n      needsApiKey: needsApiKey,\n\n      // Status decisions\n      shouldDeactivate: shouldDeactivate,\n\n      // For Notion update\n      updateActive: shouldDeactivate ? false : true,\n      updateApiKeyRequired: needsApiKey ? true : false,\n      updateConsecutiveFailures: newFailureCount,\n      updateNotes:\n        `Last failed: ${new Date().toLocaleString('en-GB', { timeZone: 'Europe/London' })}. ` +\n        `Consecutive failures: ${newFailureCount}. ` +\n        `Error type: ${errorAnalysis.type}. ` +\n        `Message: ${errorAnalysis.message}`,\n      updateLastErrorDate: new Date().toISOString(),\n\n      // Workflow control\n      failed: true,\n      continueLoop: true,\n      needsNotionUpdate: true,\n      failedAt: new Date().toISOString(),\n    },\n  };\n\n  items.push(errorResult);\n} catch (error) {\n  console.error(\"Error in Enhanced Error Handler:\", error);\n  items.push({\n    json: {\n      error: true,\n      errorMessage: error.message,\n      failed: true,\n      continueLoop: true,\n      needsNotionUpdate: false,\n    },\n  });\n}\n\n// Helper function to analyse different error types\nfunction analyzeError(httpResponse) {\n  const data = httpResponse?.data || \"\";\n  const statusCode = httpResponse?.statusCode;\n\n  if (statusCode === 401) {\n    return {\n      type: \"AUTHENTICATION_REQUIRED\",\n      statusCode: 401,\n      message: \"Authentication required - API key needed\",\n      needsApiKey: true,\n    };\n  }\n\n  if (statusCode === 403) {\n    return {\n      type: \"ACCESS_FORBIDDEN\",\n      statusCode: 403,\n      message: \"Access forbidden - may need API key\",\n      needsApiKey: true,\n    };\n  }\n\n  if (statusCode === 404) {\n    return {\n      type: \"FEED_NOT_FOUND\",\n      statusCode: 404,\n      message: \"RSS feed not found - URL may have changed\",\n      needsApiKey: false,\n    };\n  }\n\n  if (!data || data.trim() === \"\") {\n    return {\n      type: \"EMPTY_RESPONSE\",\n      statusCode: statusCode || 200,\n      message: \"Empty response received\",\n      needsApiKey: false,\n    };\n  }\n\n  return {\n    type: \"UNKNOWN_ERROR\",\n    statusCode: statusCode || 0,\n    message: \"Unknown error occurred\",\n    needsApiKey: false,\n  };\n}\n\nreturn items;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [704, 1072],
      "id": "70ed09b9-d840-4ed5-8694-91a743964a02",
      "name": "RSS Error Handler"
    },
    {
      "parameters": {
        "jsCode": "// Automatically deactivates RSS sources after multiple consecutive failures\n// Updates Notion database with failure tracking and API key requirements\n\nconst items = [];\n\ntry {\n  // Get all items from error handling\n  const allItems = $input.all();\n  const staticData = $getWorkflowStaticData(\"global\");\n  const sourceErrors = staticData.sourceErrors || {};\n\n  // Track sources that need updates\n  const sourcesToUpdate = [];\n  const sourcesToFlag = [];\n\n  for (const item of allItems) {\n    const data = item.json;\n\n    // Skip non-error items\n    if (!data.failed) {\n      items.push(item);\n      continue;\n    }\n\n    const sourceId = data.sourceId;\n    const errorHistory = sourceErrors[`source_${sourceId}`];\n\n    if (!errorHistory) {\n      items.push(item);\n      continue;\n    }\n\n    // Determine what updates are needed\n    const updates = {\n      sourceId,\n      sourceName: data.sourceName,\n      updates: [],\n    };\n\n    // Check if source should be deactivated\n    if (\n      errorHistory.shouldDeactivate &&\n      errorHistory.consecutiveFailures >= 3\n    ) {\n      updates.updates.push({\n        field: \"Active\",\n        value: false,\n        reason: `Auto-deactivated after ${errorHistory.consecutiveFailures} consecutive failures`,\n      });\n    }\n\n    // Check if API key is needed\n    if (errorHistory.needsApiKey) {\n      updates.updates.push({\n        field: \"API Key Required\",\n        value: true,\n        reason: \"Source requires authentication or subscription\",\n      });\n    }\n\n    // Add failure count to notes\n    const errorSummary =\n      `Last failed: ${new Date().toLocaleString('en-GB', { timeZone: 'Europe/London' })}. ` +\n      `Consecutive failures: ${errorHistory.consecutiveFailures}. ` +\n      `Error type: ${data.errorType}. ` +\n      `Message: ${data.errorMessage}`;\n\n    updates.updates.push({\n      field: \"Notes\",\n      value: errorSummary,\n      reason: \"Error tracking information\",\n    });\n\n    if (updates.updates.length > 0) {\n      sourcesToUpdate.push(updates);\n    }\n\n    // Create output item for the source update\n    const updateItem = {\n      json: {\n        // Notion page identification\n        id: sourceId,\n        sourceName: data.sourceName,\n\n        // Status updates\n        shouldDeactivate: errorHistory.shouldDeactivate,\n        needsApiKey: errorHistory.needsApiKey,\n        consecutiveFailures: errorHistory.consecutiveFailures,\n\n        // Update data for Notion\n        updateActive: errorHistory.shouldDeactivate ? false : true,\n        updateApiKeyRequired: errorHistory.needsApiKey ? true : false,\n        updateNotes: errorSummary,\n        updateLastErrorDate: new Date().toISOString(),\n\n        // Original error data\n        errorType: data.errorType,\n        errorMessage: data.errorMessage,\n        failedAt: data.failedAt,\n\n        // Control flags\n        needsNotionUpdate: true,\n        isErrorHandling: true,\n      },\n    };\n\n    items.push(updateItem);\n  }\n\n  // Log summary of actions\n  console.log(`Source Management Summary:`);\n  console.log(`- Total items processed: ${allItems.length}`);\n  console.log(`- Sources needing updates: ${sourcesToUpdate.length}`);\n\n  sourcesToUpdate.forEach((source) => {\n    console.log(`Source: ${source.sourceName}`);\n    source.updates.forEach((update) => {\n      console.log(`  - ${update.field}: ${update.value} (${update.reason})`);\n    });\n  });\n\n  // If no items need updates, create a summary item\n  if (items.length === 0) {\n    items.push({\n      json: {\n        summary: \"No source updates needed\",\n        processedAt: new Date().toISOString(),\n        totalItemsChecked: allItems.length,\n        needsNotionUpdate: false,\n      },\n    });\n  }\n} catch (error) {\n  console.error(\"Error in auto-deactivate sources:\", error);\n\n  items.push({\n    json: {\n      error: true,\n      errorMessage: error.message,\n      errorType: \"AUTO_DEACTIVATE_ERROR\",\n      processedAt: new Date().toISOString(),\n      needsNotionUpdate: false,\n    },\n  });\n}\n\nreturn items;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [944, 1072],
      "id": "7ed2ce7b-f825-48b3-a357-991a0fa71d82",
      "name": "Auto-Deactivate Source"
    }
  ],
  "pinData": {},
  "connections": {
    "Schedule": {
      "main": [
        [
          {
            "node": "Fetch Active Sources",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Active Sources": {
      "main": [
        [
          {
            "node": "Update Last Scraped Date",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Sources": {
      "main": [
        [
          {
            "node": "Loop Feeds",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Feeds": {
      "main": [
        [
          {
            "node": "Accumulate All Articles",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Download RSS",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Download RSS": {
      "main": [
        [
          {
            "node": "Fetch OK?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch OK?": {
      "main": [
        [
          {
            "node": "Parse RSS",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "RSS Error Handler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse RSS": {
      "main": [
        [
          {
            "node": "Store Articles (Static)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store Articles (Static)": {
      "main": [
        [
          {
            "node": "Loop Feeds",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Accumulate All Articles": {
      "main": [
        [
          {
            "node": "Get Recent Articles",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Recent Articles": {
      "main": [
        [
          {
            "node": "Remove Duplicates",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Remove Duplicates": {
      "main": [
        [
          {
            "node": "Pre-filter",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Pre-filter": {
      "main": [
        [
          {
            "node": "Make AI Batches",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Make AI Batches": {
      "main": [
        [
          {
            "node": "AI Content Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Content Analysis": {
      "main": [
        [
          {
            "node": "Merge Batch Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Batch Results": {
      "main": [
        [
          {
            "node": "Create Pipeline Entry",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Pipeline Entry": {
      "main": [[]]
    },
    "Update Last Scraped Date": {
      "main": [
        [
          {
            "node": "Validate Sources",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Need Notion Update?": {
      "main": [
        [
          {
            "node": "Update Source Status",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Loop Feeds",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Source Status": {
      "main": [
        [
          {
            "node": "Loop Feeds",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Pipeline Metrics": {
      "main": [
        [
          {
            "node": "Create a database page",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "RSS Error Handler": {
      "main": [
        [
          {
            "node": "Auto-Deactivate Source",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Auto-Deactivate Source": {
      "main": [
        [
          {
            "node": "Need Notion Update?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "50d1caa8-8a65-469d-a443-3c7746cb0055",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "d052f68fee6cbc1f0a1b7b4daa7281384655d7a51d1cb62c7e57bbd86329486d"
  },
  "id": "iWv3QwvaZlsSc7q8",
  "tags": []
}
