{
  "name": "RSS to Pipeline",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "hours",
              "hoursInterval": 1
            }
          ]
        }
      },
      "id": "schedule-trigger",
      "name": "Schedule Trigger",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [250, 300]
    },
    {
      "parameters": {
        "operation": "getMany",
        "dataTableId": "rss_sources",
        "returnAll": true,
        "filters": {
          "conditions": [
            {
              "field": "active",
              "operator": "equal",
              "value": true
            }
          ]
        },
        "options": {
          "sort": {
            "sortFieldsUi": {
              "sortField": [
                {
                  "fieldName": "priority",
                  "order": "DESC"
                }
              ]
            }
          }
        }
      },
      "id": "get-active-sources",
      "name": "Get Active RSS Sources",
      "type": "@n8n/n8n-nodes-langchain.dataTable",
      "typeVersion": 1,
      "position": [470, 300]
    },
    {
      "parameters": {},
      "id": "loop-sources",
      "name": "Loop Through Sources",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [690, 300]
    },
    {
      "parameters": {
        "url": "={{ $json.url }}",
        "options": {
          "timeout": 30000,
          "response": {
            "response": {
              "responseFormat": "text"
            }
          }
        },
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (compatible; XavierFuentes.com RSS Reader)"
            }
          ]
        }
      },
      "id": "fetch-rss",
      "name": "Fetch RSS Feed",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [910, 300],
      "continueOnFail": true
    },
    {
      "parameters": {
        "mode": "xmlToJson",
        "options": {}
      },
      "id": "parse-xml",
      "name": "Parse RSS/Atom XML",
      "type": "n8n-nodes-base.xml",
      "typeVersion": 1.1,
      "position": [1130, 300]
    },
    {
      "parameters": {
        "jsCode": "// Extract items from RSS 2.0 or Atom feed\nconst data = items[0].json.data;\nconst sourceInfo = items[0].json;\n\nlet feedItems = [];\n\n// Try RSS 2.0 format\nif (data.rss && data.rss.channel && data.rss.channel.item) {\n  const rssItems = Array.isArray(data.rss.channel.item) \n    ? data.rss.channel.item \n    : [data.rss.channel.item];\n  \n  feedItems = rssItems.map(item => ({\n    title: item.title,\n    url: item.link,\n    guid: item.guid && typeof item.guid === 'object' ? item.guid._ : (item.guid || item.link),\n    description: item.description || item['content:encoded'] || '',\n    source_name: sourceInfo.name,\n    content_pillar: sourceInfo.content_pillar\n  }));\n}\n// Try Atom format\nelse if (data.feed && data.feed.entry) {\n  const atomEntries = Array.isArray(data.feed.entry) \n    ? data.feed.entry \n    : [data.feed.entry];\n  \n  feedItems = atomEntries.map(entry => {\n    const link = Array.isArray(entry.link) \n      ? entry.link.find(l => l.$.rel === 'alternate' || !l.$.rel)?.$.href || entry.link[0].$.href\n      : entry.link?.$.href || '';\n    \n    return {\n      title: entry.title,\n      url: link,\n      guid: entry.id || link,\n      description: entry.summary || entry.content?.$?._ || entry.content || '',\n      source_name: sourceInfo.name,\n      content_pillar: sourceInfo.content_pillar\n    };\n  });\n}\n\n// Return items\nreturn feedItems.map(item => ({ json: item }));"
      },
      "id": "extract-items",
      "name": "Extract Items",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1350, 300]
    },
    {
      "parameters": {},
      "id": "loop-articles",
      "name": "Loop Through Articles",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [1570, 300]
    },
    {
      "parameters": {
        "operation": "getMany",
        "dataTableId": "content_pipeline",
        "returnAll": true,
        "filters": {
          "conditions": [
            {
              "field": "guid",
              "operator": "equal",
              "value": "={{ $json.guid }}"
            }
          ]
        }
      },
      "id": "check-exists",
      "name": "Check If Exists",
      "type": "@n8n/n8n-nodes-langchain.dataTable",
      "typeVersion": 1,
      "position": [1790, 300]
    },
    {
      "parameters": {
        "conditions": {
          "number": [
            {
              "value1": "={{ $json.length || 0 }}",
              "operation": "equal",
              "value2": 0
            }
          ]
        }
      },
      "id": "is-new",
      "name": "Is New Article?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [2010, 300]
    },
    {
      "parameters": {
        "modelId": {
          "__rl": true,
          "value": "gpt-4o",
          "mode": "list",
          "cachedResultName": "gpt-4o"
        },
        "messages": {
          "values": [
            {
              "message": "=You are an expert content curator for a fractional CTO's thought leadership platform.\n\nTarget audience: CTOs, Engineering Managers, Tech Leaders, Product Managers, Founders\n\nContent Pillars:\n- Technology Strategy (30%)\n- Leadership & Management (25%)\n- Execution & Delivery (20%)\n- Founder Lessons (15%)\n- Market & AI Trends (10%)\n\nScore the following article on a composite quality scale (1-10) considering:\n\n1. RELEVANCE: How relevant is this to our target audience (CTOs, tech leaders, founders)?\n2. ACTIONABILITY: How practical and actionable is this content? Does it provide frameworks, templates, or specific steps?\n3. DEPTH: How deep is the technical/strategic analysis? Does it go beyond surface-level observations?\n\nProvide a single quality score (1-10) that balances all three factors.\n\nArticle to score:\nTitle: {{ $json.title }}\nSource: {{ $json.source_name }}\nPillar: {{ $json.content_pillar }}\nDescription: {{ $json.description }}\n\nReturn ONLY a JSON object in this exact format:\n{\n  \"quality_score\": 8.5,\n  \"reasoning\": \"Brief explanation in 1-2 sentences\"\n}"
            }
          ]
        },
        "options": {
          "temperature": 0.3,
          "maxTokens": 200
        },
        "text": "={{ $json.description }}"
      },
      "id": "score-article",
      "name": "Score Article (AI)",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1.4,
      "position": [2230, 200],
      "credentials": {
        "openAiApi": {
          "id": "YOUR_OPENAI_CREDENTIAL_ID",
          "name": "OpenAI account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const item = items[0].json;\n\n// Extract score from AI response\nlet aiResponse;\ntry {\n  const responseText = item.message?.content || item.text || item.response || '{}';\n  aiResponse = typeof responseText === 'string' \n    ? JSON.parse(responseText) \n    : responseText;\n} catch (error) {\n  aiResponse = {\n    quality_score: 5.0,\n    reasoning: 'Default score due to parsing error'\n  };\n}\n\n// Generate UUID for new item\nconst crypto = require('crypto');\nconst id = crypto.randomUUID();\n\n// Get today's date in YYYY-MM-DD format\nconst today = new Date().toISOString().split('T')[0];\n\nreturn [{\n  json: {\n    id: id,\n    guid: item.guid,\n    title: item.title,\n    url: item.url,\n    source_name: item.source_name,\n    content_pillar: item.content_pillar,\n    description: item.description?.substring(0, 500) || '',\n    quality_score: parseFloat(aiResponse.quality_score) || 5.0,\n    status: 'research',\n    target_channel: null,\n    word_count_target: null,\n    created_date: today,\n    github_path: null,\n    github_commit_url: null,\n    notes: aiResponse.reasoning || ''\n  }\n}];"
      },
      "id": "calculate-score",
      "name": "Calculate Quality Score",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2450, 200]
    },
    {
      "parameters": {
        "operation": "create",
        "dataTableId": "content_pipeline",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldName": "id",
              "fieldValue": "={{ $json.id }}"
            },
            {
              "fieldName": "guid",
              "fieldValue": "={{ $json.guid }}"
            },
            {
              "fieldName": "title",
              "fieldValue": "={{ $json.title }}"
            },
            {
              "fieldName": "url",
              "fieldValue": "={{ $json.url }}"
            },
            {
              "fieldName": "source_name",
              "fieldValue": "={{ $json.source_name }}"
            },
            {
              "fieldName": "content_pillar",
              "fieldValue": "={{ $json.content_pillar }}"
            },
            {
              "fieldName": "description",
              "fieldValue": "={{ $json.description }}"
            },
            {
              "fieldName": "quality_score",
              "fieldValue": "={{ $json.quality_score }}"
            },
            {
              "fieldName": "status",
              "fieldValue": "={{ $json.status }}"
            },
            {
              "fieldName": "target_channel",
              "fieldValue": "={{ $json.target_channel }}"
            },
            {
              "fieldName": "word_count_target",
              "fieldValue": "={{ $json.word_count_target }}"
            },
            {
              "fieldName": "created_date",
              "fieldValue": "={{ $json.created_date }}"
            },
            {
              "fieldName": "github_path",
              "fieldValue": "={{ $json.github_path }}"
            },
            {
              "fieldName": "github_commit_url",
              "fieldValue": "={{ $json.github_commit_url }}"
            },
            {
              "fieldName": "notes",
              "fieldValue": "={{ $json.notes }}"
            }
          ]
        }
      },
      "id": "insert-pipeline",
      "name": "Insert Into Pipeline",
      "type": "@n8n/n8n-nodes-langchain.dataTable",
      "typeVersion": 1,
      "position": [2670, 200]
    },
    {
      "parameters": {
        "jsCode": "// Aggregate all inserted items\nconst allItems = $('Insert Into Pipeline').all();\n\nconst summary = {\n  total_new_items: allItems.length,\n  items: allItems.map(item => ({\n    title: item.json.title,\n    source: item.json.source_name,\n    pillar: item.json.content_pillar,\n    score: item.json.quality_score\n  }))\n};\n\nreturn [{ json: summary }];"
      },
      "id": "send-summary",
      "name": "Send Summary Email",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2890, 300]
    }
  ],
  "connections": {
    "Schedule Trigger": {
      "main": [[{ "node": "Get Active RSS Sources", "type": "main", "index": 0 }]]
    },
    "Get Active RSS Sources": {
      "main": [[{ "node": "Loop Through Sources", "type": "main", "index": 0 }]]
    },
    "Loop Through Sources": {
      "main": [
        [{ "node": "Fetch RSS Feed", "type": "main", "index": 0 }],
        [{ "node": "Send Summary Email", "type": "main", "index": 0 }]
      ]
    },
    "Fetch RSS Feed": {
      "main": [[{ "node": "Parse RSS/Atom XML", "type": "main", "index": 0 }]]
    },
    "Parse RSS/Atom XML": {
      "main": [[{ "node": "Extract Items", "type": "main", "index": 0 }]]
    },
    "Extract Items": {
      "main": [[{ "node": "Loop Through Articles", "type": "main", "index": 0 }]]
    },
    "Loop Through Articles": {
      "main": [
        [{ "node": "Check If Exists", "type": "main", "index": 0 }],
        [{ "node": "Loop Through Sources", "type": "main", "index": 0 }]
      ]
    },
    "Check If Exists": {
      "main": [[{ "node": "Is New Article?", "type": "main", "index": 0 }]]
    },
    "Is New Article?": {
      "main": [[{ "node": "Score Article (AI)", "type": "main", "index": 0 }]]
    },
    "Score Article (AI)": {
      "main": [[{ "node": "Calculate Quality Score", "type": "main", "index": 0 }]]
    },
    "Calculate Quality Score": {
      "main": [[{ "node": "Insert Into Pipeline", "type": "main", "index": 0 }]]
    },
    "Insert Into Pipeline": {
      "main": [[{ "node": "Loop Through Articles", "type": "main", "index": 0 }]]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 0,
  "updatedAt": "2025-01-07T00:00:00.000Z",
  "versionId": "1"
}
