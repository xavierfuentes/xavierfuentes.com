{
  "name": "Weekly Content Selection",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "cronExpression",
              "cronExpression": "0 9 * * 0"
            }
          ]
        }
      },
      "id": "weekly-trigger",
      "name": "Sunday 9 AM Trigger",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [200, 300]
    },
    {
      "parameters": {
        "resource": "databasePage",
        "operation": "getAll",
        "databaseId": {
          "__rl": true,
          "value": "https://www.notion.so/9d899a561818444f8de1d7bd72ee1528",
          "mode": "url"
        },
        "filterType": "manual",
        "filters": {
          "conditions": [
            {
              "key": "Status|select",
              "condition": "equals",
              "selectValue": "Research"
            }
          ]
        },
        "options": {
          "limit": 50
        }
      },
      "id": "fetch-research-queue",
      "name": "Fetch Research Queue",
      "type": "n8n-nodes-base.notion",
      "typeVersion": 2.2,
      "position": [400, 300],
      "credentials": {
        "notionApi": {
          "id": "lC4G957VFihVvFG2",
          "name": "Notion account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Auto-Archive Engine - Manages research queue lifecycle\n// Archives stale, low-scoring, or excess articles to keep queue fresh\n\nconst articles = $input.all();\nconst now = new Date();\nconst ONE_DAY = 24 * 60 * 60 * 1000;\n\n// Archive criteria\nconst MAX_QUEUE_SIZE = 60; // Keep only top 60 articles\nconst AUTO_ARCHIVE_DAYS = 45; // Archive anything older than 45 days\nconst STALE_THRESHOLD_DAYS = 30; // Archive if older than 30 days AND low score\nconst LOW_SCORE_THRESHOLD = 15; // Combined with age for archiving\nconst VERY_LOW_SCORE_THRESHOLD = 12; // Archive immediately regardless of age\n\nconst toArchive = [];\nconst toKeep = [];\n\n// First pass: identify articles to archive based on quality/age\narticles.forEach(article => {\n  const json = article.json;\n  \n  // Calculate age\n  const createdDate = new Date(json.property_created_date || json.created_date || now);\n  const daysSinceCreated = (now - createdDate) / ONE_DAY;\n  \n  // Calculate basic score for archiving decisions\n  const relevance = json.property_relevance_score || 5;\n  const actionability = json.property_actionability_score || 5;\n  const depth = json.property_depth_score || 5;\n  const priority = json.property_priority || 'Medium';\n  \n  const priorityBonus = { 'High': 4, 'Medium': 2, 'Low': 0 }[priority] || 2;\n  const basicScore = (relevance * 3) + (actionability * 2) + depth + priorityBonus;\n  \n  // Archive decision logic\n  const shouldArchive = \n    // Very low quality - archive immediately\n    basicScore < VERY_LOW_SCORE_THRESHOLD ||\n    // Very old - archive regardless of score\n    daysSinceCreated > AUTO_ARCHIVE_DAYS ||\n    // Medium age + low score - archive gradually\n    (daysSinceCreated > STALE_THRESHOLD_DAYS && basicScore < LOW_SCORE_THRESHOLD);\n  \n  if (shouldArchive) {\n    toArchive.push({\n      ...article,\n      json: {\n        ...json,\n        archive_reason: getArchiveReason(basicScore, daysSinceCreated),\n        archived_at: now.toISOString(),\n        final_score: basicScore\n      }\n    });\n  } else {\n    toKeep.push({\n      ...article,\n      json: {\n        ...json,\n        days_in_queue: Math.round(daysSinceCreated),\n        basic_score: basicScore\n      }\n    });\n  }\n});\n\n// Second pass: if queue is still too large, archive lowest scoring\nif (toKeep.length > MAX_QUEUE_SIZE) {\n  // Sort by basic score (lowest first) and archive the excess\n  toKeep.sort((a, b) => a.json.basic_score - b.json.basic_score);\n  \n  const excess = toKeep.splice(0, toKeep.length - MAX_QUEUE_SIZE);\n  excess.forEach(article => {\n    toArchive.push({\n      ...article,\n      json: {\n        ...article.json,\n        archive_reason: 'Queue size limit - lowest scoring',\n        archived_at: now.toISOString(),\n        final_score: article.json.basic_score\n      }\n    });\n  });\n}\n\n// Helper function to determine archive reason\nfunction getArchiveReason(score, days) {\n  if (score < VERY_LOW_SCORE_THRESHOLD) return `Very low quality (score: ${score})`;\n  if (days > AUTO_ARCHIVE_DAYS) return `Too old (${Math.round(days)} days)`;\n  if (days > STALE_THRESHOLD_DAYS && score < LOW_SCORE_THRESHOLD) {\n    return `Stale and low quality (${Math.round(days)} days, score: ${score})`;\n  }\n  return 'Queue management';\n}\n\n// Summary statistics\nconst archiveSummary = {\n  total_reviewed: articles.length,\n  archived_count: toArchive.length,\n  kept_count: toKeep.length,\n  archive_reasons: {},\n  avg_archived_score: 0,\n  avg_kept_score: 0\n};\n\n// Calculate archive reason distribution\ntoArchive.forEach(article => {\n  const reason = article.json.archive_reason.split(' (')[0]; // Get main reason\n  archiveSummary.archive_reasons[reason] = (archiveSummary.archive_reasons[reason] || 0) + 1;\n});\n\n// Calculate average scores\nif (toArchive.length > 0) {\n  archiveSummary.avg_archived_score = Math.round(\n    (toArchive.reduce((sum, a) => sum + a.json.final_score, 0) / toArchive.length) * 10\n  ) / 10;\n}\n\nif (toKeep.length > 0) {\n  archiveSummary.avg_kept_score = Math.round(\n    (toKeep.reduce((sum, a) => sum + a.json.basic_score, 0) / toKeep.length) * 10\n  ) / 10;\n}\n\nconsole.log('üóÑÔ∏è Auto-Archive Summary:');\nconsole.log(`  Total articles reviewed: ${archiveSummary.total_reviewed}`);\nconsole.log(`  Articles to archive: ${archiveSummary.archived_count}`);\nconsole.log(`  Articles kept: ${archiveSummary.kept_count}`);\nconsole.log(`  Archive reasons: ${Object.entries(archiveSummary.archive_reasons).map(([r,c]) => `${r}(${c})`).join(', ')}`);\nconsole.log(`  Avg scores - Archived: ${archiveSummary.avg_archived_score}, Kept: ${archiveSummary.avg_kept_score}`);\n\n// Return data for next steps\nreturn [{\n  json: {\n    archive_summary: archiveSummary,\n    articles_to_archive: toArchive,\n    articles_to_keep: toKeep,\n    archive_timestamp: now.toISOString()\n  }\n}];"
      },
      "id": "auto-archive-engine",
      "name": "Auto-Archive Engine",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [500, 300]
    },
    {
      "parameters": {
        "jsCode": "// Prepare archive updates for Notion\nconst archiveData = $input.item.json;\nconst articlesToArchive = archiveData.articles_to_archive;\n\nif (articlesToArchive.length === 0) {\n  console.log('No articles to archive this week');\n  return [];\n}\n\nconst archiveUpdates = articlesToArchive.map(article => ({\n  json: {\n    id: article.json.id,\n    status: 'Archived',\n    archive_reason: article.json.archive_reason,\n    archived_at: article.json.archived_at,\n    final_score: article.json.final_score\n  }\n}));\n\nconsole.log(`Preparing to archive ${archiveUpdates.length} articles`);\n\nreturn archiveUpdates;"
      },
      "id": "prepare-archive-updates",
      "name": "Prepare Archive Updates",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [700, 200]
    },
    {
      "parameters": {
        "resource": "databasePage",
        "operation": "update",
        "pageId": {
          "__rl": true,
          "value": "={{ $json.id }}",
          "mode": "id"
        },
        "propertiesUi": {
          "propertyValues": [
            {
              "key": "Status|select",
              "selectValue": "Archived"
            }
          ]
        },
        "options": {}
      },
      "id": "archive-articles",
      "name": "Archive Articles",
      "type": "n8n-nodes-base.notion",
      "typeVersion": 2.2,
      "position": [900, 200],
      "credentials": {
        "notionApi": {
          "id": "lC4G957VFihVvFG2",
          "name": "Notion account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Extract kept articles for content selection\nconst archiveData = $('Auto-Archive Engine').item.json;\nconst keptArticles = archiveData.articles_to_keep;\n\nconsole.log(`Proceeding with ${keptArticles.length} articles for content selection`);\n\nreturn keptArticles;"
      },
      "id": "extract-kept-articles",
      "name": "Extract Kept Articles",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [600, 400]
    },
    {
      "parameters": {
        "jsCode": "// Weekly Content Selection Engine\n// Calculates updated scores with pillar balancing and trending boost\n// Selects optimal content mix for upcoming week\n\nconst articles = $input.all();\nconst now = new Date();\nconst ONE_DAY = 24 * 60 * 60 * 1000;\n\n// Content strategy targets from docs\nconst PILLAR_TARGETS = {\n  'Technology Strategy': 0.30,\n  'Leadership & Management': 0.25,\n  'Execution & Delivery': 0.20,\n  'Founder Lessons': 0.15,\n  'Market & AI Trends': 0.10\n};\n\n// Weekly content needs\nconst WEEKLY_CONTENT_NEEDS = {\n  blog: 1, // 2 per month = ~0.5 per week, but let's plan 1 ahead\n  linkedin: 3,\n  newsletter: 1\n};\n\n// Calculate current pillar distribution\nconst pillarCounts = {};\nconst totalArticles = articles.length;\n\narticles.forEach(article => {\n  const pillar = article.json.property_content_pillar || 'Unknown';\n  pillarCounts[pillar] = (pillarCounts[pillar] || 0) + 1;\n});\n\n// Calculate pillar balance scores (lower = more needed)\nconst pillarBalanceScores = {};\nObject.keys(PILLAR_TARGETS).forEach(pillar => {\n  const currentRatio = (pillarCounts[pillar] || 0) / totalArticles;\n  const targetRatio = PILLAR_TARGETS[pillar];\n  // If we're under target, give boost (lower score = higher priority)\n  pillarBalanceScores[pillar] = currentRatio / targetRatio;\n});\n\n// Enhanced scoring function\nfunction calculateWeeklyScore(article) {\n  const json = article.json;\n  \n  // Base scores\n  const relevance = json.property_relevance_score || 5;\n  const actionability = json.property_actionability_score || 5;\n  const depth = json.property_depth_score || 5;\n  const priority = json.property_priority || 'Medium';\n  \n  // Base calculation: (Relevance √ó 3) + (Actionability √ó 2) + (Depth √ó 1)\n  let baseScore = (relevance * 3) + (actionability * 2) + depth;\n  \n  // Priority bonus\n  const priorityBonus = {\n    'High': 4,\n    'Medium': 2,\n    'Low': 0\n  }[priority] || 2;\n  \n  baseScore += priorityBonus;\n  \n  // Pillar balance modifier\n  const pillar = json.property_content_pillar || 'Unknown';\n  const balanceMultiplier = pillarBalanceScores[pillar] || 1;\n  // If pillar is underrepresented (balance < 1), boost score\n  const pillarBoost = balanceMultiplier < 1 ? (2 - balanceMultiplier) * 3 : 0;\n  \n  baseScore += pillarBoost;\n  \n  // Trending boost (articles from last 7 days get bonus)\n  const createdDate = new Date(json.property_created_date || json.created_date);\n  const daysSinceCreated = (now - createdDate) / ONE_DAY;\n  \n  let trendingBoost = 0;\n  if (daysSinceCreated <= 3) trendingBoost = 3; // Very recent\n  else if (daysSinceCreated <= 7) trendingBoost = 2; // Recent\n  else if (daysSinceCreated <= 14) trendingBoost = 1; // Somewhat recent\n  \n  baseScore += trendingBoost;\n  \n  // Research complexity consideration\n  // Higher depth scores might need more research time - slight penalty for immediate use\n  const complexityPenalty = depth >= 8 ? 1 : 0;\n  baseScore -= complexityPenalty;\n  \n  return Math.round(baseScore * 10) / 10; // Round to 1 decimal\n}\n\n// Calculate updated scores for all articles\nconst scoredArticles = articles.map(article => {\n  const weeklyScore = calculateWeeklyScore(article);\n  \n  return {\n    ...article,\n    json: {\n      ...article.json,\n      weekly_score: weeklyScore,\n      pillar_balance_score: pillarBalanceScores[article.json.property_content_pillar] || 1,\n      trending_days: Math.round((now - new Date(article.json.property_created_date || article.json.created_date)) / ONE_DAY)\n    }\n  };\n});\n\n// Sort by weekly score (highest first)\nconst sortedArticles = scoredArticles.sort((a, b) => b.json.weekly_score - a.json.weekly_score);\n\n// Select content for the week\nconst selections = {\n  blog_candidates: [],\n  linkedin_candidates: [],\n  should_process: []\n};\n\n// Blog content selection (high-quality, research-heavy)\nconst blogCandidates = sortedArticles.filter(a => \n  a.json.weekly_score >= 22 && \n  (a.json.property_depth_score || 5) >= 6\n).slice(0, 3); // Top 3 for choice\n\nselections.blog_candidates = blogCandidates;\n\n// LinkedIn content selection (actionable, engaging)\nconst linkedinCandidates = sortedArticles.filter(a => \n  a.json.weekly_score >= 18 && \n  (a.json.property_actionability_score || 5) >= 6\n).slice(0, 6); // Top 6 for choice\n\nselections.linkedin_candidates = linkedinCandidates;\n\n// Auto-select \"Should Process\" - top 1 blog + top 3 LinkedIn (avoiding duplicates)\nconst autoSelected = new Set();\n\n// Add top blog candidate\nif (blogCandidates.length > 0) {\n  selections.should_process.push(blogCandidates[0]);\n  autoSelected.add(blogCandidates[0].json.id);\n}\n\n// Add top LinkedIn candidates (skip if already selected for blog)\nlet linkedinCount = 0;\nfor (const candidate of linkedinCandidates) {\n  if (!autoSelected.has(candidate.json.id) && linkedinCount < 3) {\n    selections.should_process.push(candidate);\n    autoSelected.add(candidate.json.id);\n    linkedinCount++;\n  }\n}\n\n// Summary statistics\nconst summary = {\n  total_articles_reviewed: articles.length,\n  blog_candidates_found: blogCandidates.length,\n  linkedin_candidates_found: linkedinCandidates.length,\n  auto_selected_count: selections.should_process.length,\n  pillar_distribution: pillarCounts,\n  pillar_balance_scores: pillarBalanceScores,\n  top_score: sortedArticles.length > 0 ? sortedArticles[0].json.weekly_score : 0,\n  selection_timestamp: now.toISOString()\n};\n\nconsole.log('üìä Weekly Content Selection Summary:');\nconsole.log(`  Articles reviewed: ${summary.total_articles_reviewed}`);\nconsole.log(`  Blog candidates: ${summary.blog_candidates_found}`);\nconsole.log(`  LinkedIn candidates: ${summary.linkedin_candidates_found}`);\nconsole.log(`  Auto-selected: ${summary.auto_selected_count}`);\nconsole.log(`  Top score: ${summary.top_score}`);\n\nreturn [{\n  json: {\n    selections,\n    summary,\n    sorted_articles: sortedArticles.slice(0, 10) // Top 10 for email\n  }\n}];"
      },
      "id": "content-selection-engine",
      "name": "Content Selection Engine",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [600, 300]
    },
    {
      "parameters": {
        "jsCode": "// Update \"Should Process\" for selected articles\nconst selectionData = $input.item.json;\nconst shouldProcessArticles = selectionData.selections.should_process;\n\nconst updates = shouldProcessArticles.map(article => ({\n  json: {\n    id: article.json.id,\n    should_process: true,\n    weekly_score: article.json.weekly_score,\n    selection_reason: 'Auto-selected by weekly content selection',\n    selected_at: new Date().toISOString()\n  }\n}));\n\nconsole.log(`Marking ${updates.length} articles as \"Should Process\"`);\n\nreturn updates;"
      },
      "id": "prepare-updates",
      "name": "Prepare Should Process Updates",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [800, 300]
    },
    {
      "parameters": {
        "resource": "databasePage",
        "operation": "update",
        "pageId": {
          "__rl": true,
          "value": "={{ $json.id }}",
          "mode": "id"
        },
        "propertiesUi": {
          "propertyValues": [
            {
              "key": "Should Process|checkbox",
              "checkboxValue": true
            }
          ]
        },
        "options": {}
      },
      "id": "update-should-process",
      "name": "Update Should Process",
      "type": "n8n-nodes-base.notion",
      "typeVersion": 2.2,
      "position": [1000, 300],
      "credentials": {
        "notionApi": {
          "id": "lC4G957VFihVvFG2",
          "name": "Notion account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Generate email summary for manual review\nconst selectionData = $('Content Selection Engine').item.json;\nconst { selections, summary, sorted_articles } = selectionData;\n\n// Build HTML email content\nlet emailBody = `<h2>üìö Weekly Content Selection - ${new Date().toLocaleDateString('en-GB', { \n  weekday: 'long', \n  year: 'numeric', \n  month: 'long', \n  day: 'numeric',\n  timeZone: 'Europe/London'\n})}</h2>\\n\\n`;\n\n// Add scheduling note\nemailBody += `<p><strong>üìÖ Optimal Publishing Schedule:</strong><br>\\n`;\nemailBody += `‚Ä¢ Tuesday: Framework/template shares (peak B2B engagement)<br>\\n`;\nemailBody += `‚Ä¢ Wednesday: Industry observations/hot takes<br>\\n`;\nemailBody += `‚Ä¢ Thursday: Personal lessons/behind-the-scenes</p>\\n\\n`;\n\n// Summary section\nemailBody += `<h3>üìä Selection Summary</h3>\\n`;\nemailBody += `<ul>\\n`;\nemailBody += `  <li><strong>Articles Reviewed:</strong> ${summary.total_articles_reviewed}</li>\\n`;\nemailBody += `  <li><strong>Blog Candidates:</strong> ${summary.blog_candidates_found}</li>\\n`;\nemailBody += `  <li><strong>LinkedIn Candidates:</strong> ${summary.linkedin_candidates_found}</li>\\n`;\nemailBody += `  <li><strong>Auto-Selected:</strong> ${summary.auto_selected_count}</li>\\n`;\nemailBody += `</ul>\\n\\n`;\n\n// Pillar balance\nemailBody += `<h3>üéØ Content Pillar Balance</h3>\\n`;\nemailBody += `<ul>\\n`;\nObject.entries(summary.pillar_distribution).forEach(([pillar, count]) => {\n  const percentage = ((count / summary.total_articles_reviewed) * 100).toFixed(1);\n  emailBody += `  <li><strong>${pillar}:</strong> ${count} articles (${percentage}%)</li>\\n`;\n});\nemailBody += `</ul>\\n\\n`;\n\n// Auto-selected articles\nif (selections.should_process.length > 0) {\n  emailBody += `<h3>‚úÖ Auto-Selected for Processing</h3>\\n`;\n  emailBody += `<p>These articles have been automatically marked as \"Should Process\":</p>\\n`;\n  emailBody += `<ul>\\n`;\n  \n  selections.should_process.forEach(article => {\n    const title = article.json.property_title || 'Untitled';\n    const pillar = article.json.property_content_pillar || 'Unknown';\n    const priority = article.json.property_priority || 'Medium';\n    const score = article.json.weekly_score || 0;\n    \n    emailBody += `  <li><strong>${title}</strong><br>\\n`;\n    emailBody += `      Pillar: ${pillar} | Priority: ${priority} | Score: ${score}<br>\\n`;\n    emailBody += `      <a href=\"${article.json.property_article_link}\">Read Original</a></li>\\n`;\n  });\n  \n  emailBody += `</ul>\\n\\n`;\n}\n\n// Blog candidates\nif (selections.blog_candidates.length > 0) {\n  emailBody += `<h3>üìù Blog Article Candidates</h3>\\n`;\n  emailBody += `<p>Top candidates for long-form content (high depth + research value):</p>\\n`;\n  emailBody += `<ul>\\n`;\n  \n  selections.blog_candidates.forEach((article, index) => {\n    const title = article.json.property_title || 'Untitled';\n    const pillar = article.json.property_content_pillar || 'Unknown';\n    const scores = `R:${article.json.property_relevance_score||0} A:${article.json.property_actionability_score||0} D:${article.json.property_depth_score||0}`;\n    const weeklyScore = article.json.weekly_score || 0;\n    \n    emailBody += `  <li><strong>${index + 1}. ${title}</strong><br>\\n`;\n    emailBody += `      ${pillar} | Scores: ${scores} | Weekly: ${weeklyScore}<br>\\n`;\n    emailBody += `      <a href=\"${article.json.property_article_link}\">Read Original</a></li>\\n`;\n  });\n  \n  emailBody += `</ul>\\n\\n`;\n}\n\n// LinkedIn candidates\nif (selections.linkedin_candidates.length > 0) {\n  emailBody += `<h3>üíº LinkedIn Content Candidates</h3>\\n`;\n  emailBody += `<p>Top candidates for social content (high actionability + engagement potential):</p>\\n`;\n  emailBody += `<ul>\\n`;\n  \n  selections.linkedin_candidates.slice(0, 5).forEach((article, index) => {\n    const title = article.json.property_title || 'Untitled';\n    const pillar = article.json.property_content_pillar || 'Unknown';\n    const actionability = article.json.property_actionability_score || 0;\n    const weeklyScore = article.json.weekly_score || 0;\n    \n    emailBody += `  <li><strong>${index + 1}. ${title}</strong><br>\\n`;\n    emailBody += `      ${pillar} | Actionability: ${actionability} | Weekly: ${weeklyScore}<br>\\n`;\n    emailBody += `      <a href=\"${article.json.property_article_link}\">Read Original</a></li>\\n`;\n  });\n  \n  emailBody += `</ul>\\n\\n`;\n}\n\n// Footer\nemailBody += `<hr>\\n`;\nemailBody += `<p><strong>Next Steps:</strong></p>\\n`;\nemailBody += `<ul>\\n`;\nemailBody += `  <li>Review auto-selected articles in <a href=\"https://www.notion.so/9d899a561818444f8de1d7bd72ee1528\">Content Pipeline</a></li>\\n`;\nemailBody += `  <li>Manually adjust \"Should Process\" if needed</li>\\n`;\nemailBody += `  <li>Begin research and content creation</li>\\n`;\nemailBody += `</ul>\\n`;\nemailBody += `<p><small>Generated at ${new Date().toLocaleString('en-GB', { timeZone: 'Europe/London' })}</small></p>`;\n\nreturn [{\n  json: {\n    subject: `üìö Weekly Content Selection - ${summary.auto_selected_count} Articles Ready`,\n    body: emailBody,\n    selections,\n    summary\n  }\n}];"
      },
      "id": "prepare-email",
      "name": "Prepare Selection Email",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [600, 500]
    },
    {
      "parameters": {
        "fromEmail": "n8n@xavierfuentes.com",
        "toEmail": "xavier@xavierfuentes.com",
        "subject": "={{ $json.subject }}",
        "emailType": "html",
        "html": "={{ $json.body }}",
        "options": {
          "allowUnauthorizedCerts": false
        }
      },
      "id": "send-email",
      "name": "Send Selection Email",
      "type": "n8n-nodes-base.emailSend",
      "typeVersion": 2.1,
      "position": [800, 500],
      "credentials": {
        "smtp": {
          "id": "SmtpCredentialsId",
          "name": "SMTP account"
        }
      }
    }
  ],
  "connections": {
    "Sunday 9 AM Trigger": {
      "main": [
        [
          {
            "node": "Fetch Research Queue",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Research Queue": {
      "main": [
        [
          {
            "node": "Auto-Archive Engine",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Auto-Archive Engine": {
      "main": [
        [
          {
            "node": "Prepare Archive Updates",
            "type": "main",
            "index": 0
          },
          {
            "node": "Extract Kept Articles",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Archive Updates": {
      "main": [
        [
          {
            "node": "Archive Articles",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Kept Articles": {
      "main": [
        [
          {
            "node": "Content Selection Engine",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Content Selection Engine": {
      "main": [
        [
          {
            "node": "Prepare Should Process Updates",
            "type": "main",
            "index": 0
          },
          {
            "node": "Prepare Selection Email",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Should Process Updates": {
      "main": [
        [
          {
            "node": "Update Should Process",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Selection Email": {
      "main": [
        [
          {
            "node": "Send Selection Email",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  }
}